---
title: "EDA"
author: "Xuechun Lu, Yuting Wen, Peter Han"
date: "25/02/2020"
output:
  github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
libraries
```{r, message=F, warning=F}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(here)
library(readxl)
```

```{r}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  numPlots = length(plots)
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }
 if (numPlots==1) {
    print(plots[[1]])
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

```

1. data processing
```{r, warning=F, message=F}
# all municipalities
municipality.list = c(
  "Burnaby", 
  "Coquitlam", 
  "Delta", 
  "Langley - City", 
  "Langley - Township",
  "Maple Ridge",
  "Maple Ridge Rural", 
  "North Vancouver - City",
  "North Vancouver - Dist",
  "Pitt Meadows", 
  "Port Coquitlam", 
  "Port Moody", 
  "Richmond", 
  "Surrey", 
  "Vancouver", 
  "White Rock", 
  "West Vancouver", 
  "Bowen Island", 
  "Anmore", 
  "Belcarra",
  "Lions Bay")

# budget and assessment data import and process
tax_pct<-read_csv(here("data", "tax_pct.csv"))
assessment_pct<-read_csv(here("data", "assessment_pct.csv"))
# omit 2016
assessment_pct<-na.omit(assessment_pct)
assessment_pct<-assessment_pct[,-c(1)]
names(assessment_pct)[2]<-paste("Municipalities")
tax_pct<-tax_pct[,-c(1)]
#head(tax_pct)
```
Note: tax_pct doesn't have Maple Ridge Rural. We decide to treat Maple Ridge Rural and Maple Ridge with the same tax. 


2019 tax pct is missing, we imputed 2019 tax by the average of previous tax pct
```{r}
tax_pct[,4]<-(tax_pct$pct_2017+tax_pct$pct_2018)/2
#tax_pct
names(tax_pct)[4]<-paste("pct_2019")
tax_pct<-rbind(tax_pct,c("Maple Ridge Rural", 6.195736, 5.6949567,5.945346))

#head(tax_pct)
```

aggregate tax and assessment
```{r}
assessment2017<-assessment_pct  %>%  filter(Year=="2017")
tax2017<-tax_pct[,1:2]
assessment2017<-assessment2017 %>% left_join(tax2017, by = c("Municipalities"))
names(assessment2017)[9]<-paste("tax")

assessment2018<-assessment_pct  %>%  filter(Year=="2018")
tax2018<-tax_pct[,c(1,3)]
assessment2018<-assessment2018 %>% left_join(tax2018, by = c("Municipalities"))
names(assessment2018)[9]<-paste("tax")

assessment2019<-assessment_pct  %>%  filter(Year=="2019")
tax2019<-tax_pct[,c(1,4)]
assessment2019<-assessment2019 %>% left_join(tax2019, by = c("Municipalities"))
names(assessment2019)[9]<-paste("tax")

pct_final<-assessment2017 %>% full_join(assessment2018) %>% full_join(assessment2019)
pct_final$tax<-as.numeric(pct_final$tax)
write.csv(pct_final, here("data","data_final.csv"))

# all pct data aggregated
#head(pct_final)

```

2019 tax is missing, we imputed 2019 tax using previous values
```{r}
tax_final <- read.csv(here("data","tax_final.csv"))
#head(tax_final)

# tax_final is the budget
tax_modified <- tax_final  %>% mutate(X2019=tax_final$X2018*(1+(((tax_final$X2017-tax_final$X2016)/tax_final$X2016 + (tax_final$X2018-tax_final$X2017)/tax_final$X2017)/2)))

# tax_modified contains all the budget values from 2016 to 2019
#head(tax_modified)
```

global variables
```{r}
# all pct aggregated
pct_final
# all budget values
tax_modified
```


2. val_plots
```{r}
# mill rate vesus year for each municipality and tax class
assessment_aggregate <- read.csv(here("data","assessment_aggregate.csv"))
dat_rate <- assessment_aggregate %>% select(Year, AddressAssessorMunicipalityDesc, TaxClassCode, rate)
#head(dat_rate)

dat_rate_1 <- dat_rate %>% filter(AddressAssessorMunicipalityDesc %in% municipality.list) %>% filter(TaxClassCode=="1") 
#head(dat_rate_1)
rate_class1 <- dat_rate_1 %>% ggplot(aes(x=Year,y=rate,group=AddressAssessorMunicipalityDesc,color=AddressAssessorMunicipalityDesc)) + geom_line() + ggtitle("mill rate for taxClass 1") + theme(legend.position = "none")
#rate_class1

dat_rate_5 <- dat_rate %>% filter(AddressAssessorMunicipalityDesc %in% municipality.list) %>% filter(TaxClassCode=="5") 
#head(dat_rate_5)
rate_class5 <- dat_rate_5 %>% ggplot(aes(x=Year,y=rate,group=AddressAssessorMunicipalityDesc,color=AddressAssessorMunicipalityDesc)) + geom_line() + ggtitle("mill rate for taxClass 5") + theme(legend.position = "none")
#rate_class5

dat_rate_6 <- dat_rate %>% filter(AddressAssessorMunicipalityDesc %in% municipality.list) %>% filter(TaxClassCode=="6") 
#head(dat_rate_6)
rate_class6 <- dat_rate_6 %>% ggplot(aes(x=Year,y=rate,group=AddressAssessorMunicipalityDesc,color=AddressAssessorMunicipalityDesc)) + geom_line() + ggtitle("mill rate for taxClass 6") + theme(legend.position = "none")
#rate_class6

#multiplot(rate_class1, rate_class5, rate_class6)

# plot assessed value vesus year for each municipality and tax class
dat_assess <- assessment_aggregate %>% select(Year, AddressAssessorMunicipalityDesc, TaxClassCode, assessTotal)
#head(dat_assess)

dat_assess_1 <- dat_assess %>% filter(AddressAssessorMunicipalityDesc %in% municipality.list) %>% filter(TaxClassCode=="1") 
#head(dat_assess_1)
assess_class1 <- dat_assess_1 %>% ggplot(aes(x=Year,y=assessTotal,group=AddressAssessorMunicipalityDesc,color=AddressAssessorMunicipalityDesc)) + geom_line() + ggtitle("assessTotal for taxClass 1") + theme(legend.position = "none")
#assess_class1

dat_assess_5 <- dat_assess %>% filter(AddressAssessorMunicipalityDesc %in% municipality.list) %>% filter(TaxClassCode=="5") 
#head(dat_assess_5)
assess_class5 <- dat_assess_5 %>% ggplot(aes(x=Year,y=assessTotal,group=AddressAssessorMunicipalityDesc,color=AddressAssessorMunicipalityDesc)) + geom_line() + ggtitle("assessTotal for taxClass 5") + theme(legend.position = "none")
#assess_class5

dat_assess_6 <- dat_assess %>% filter(AddressAssessorMunicipalityDesc %in% municipality.list) %>% filter(TaxClassCode=="6") 
#head(dat_assess_6)
assess_class6 <- dat_assess_1 %>% ggplot(aes(x=Year,y=assessTotal,group=AddressAssessorMunicipalityDesc,color=AddressAssessorMunicipalityDesc)) + geom_line() + ggtitle("assessTotal for taxClass 6") + theme(legend.position = "none")
#assess_class6

#multiplot(assess_class1, assess_class5, assess_class6)

# plot budgets vesus year
dat_tax_long <- gather(tax_modified, Year, TaxAmount, X2016:X2019, factor_key=TRUE)
#dat_tax_long
budget_plot <- dat_tax_long %>% ggplot(aes(x=Year,y=TaxAmount,group=Municipalities,color=Municipalities)) + geom_line() +ggtitle("Tax v.s Year")
#budget_plot

multiplot(rate_class1,assess_class1,budget_plot)
multiplot(rate_class5,assess_class5,budget_plot)
multiplot(rate_class6,assess_class6,budget_plot)
```


3. pct_plots
pct change of mill rates for each tax class
```{r}
pct_rate1 <- pct_final %>% 
  filter(Municipalities %in% municipality.list) %>%
  filter(TaxClassCode == "01") %>%
  ggplot(aes(x=Year, y=rate_pct, group=Municipalities, color=Municipalities)) +
    geom_line() + ggtitle("taxClass1 pct rate v.s year") + theme(legend.position = "none")

pct_rate5 <- pct_final %>% 
  filter(Municipalities %in% municipality.list) %>%
  filter(TaxClassCode == "05") %>%
  ggplot(aes(x=Year, y=rate_pct, group=Municipalities, color=Municipalities)) +
    geom_line() + ggtitle("taxClass5 pct rate v.s year") + theme(legend.position = "none")

pct_rate6 <- pct_final %>% 
  filter(Municipalities %in% municipality.list) %>%
  filter(TaxClassCode == "06") %>%
  ggplot(aes(x=Year, y=rate_pct, group=Municipalities, color=Municipalities)) +
    geom_line() + ggtitle("taxClass6 pct rate v.s year") + theme(legend.position = "none")

pct_assess1 <- pct_final %>% 
  filter(Municipalities %in% municipality.list) %>%
  filter(TaxClassCode == "01") %>%
  ggplot(aes(x=Year, y=assessTotal_pct, group=Municipalities, color=Municipalities)) +
    geom_line() + ggtitle("taxClass1 pct assessment v.s year") + theme(legend.position = "none")

pct_assess5 <- pct_final %>% 
  filter(Municipalities %in% municipality.list) %>%
  filter(TaxClassCode == "05") %>%
  ggplot(aes(x=Year, y=assessTotal_pct, group=Municipalities, color=Municipalities)) +
    geom_line() + ggtitle("taxClass5 pct assessment v.s year") + theme(legend.position = "none")

pct_assess6 <- pct_final %>% 
  filter(Municipalities %in% municipality.list) %>%
  filter(TaxClassCode == "06") %>%
  ggplot(aes(x=Year, y=assessTotal_pct, group=Municipalities, color=Municipalities)) +
    geom_line() + ggtitle("taxClass6 pct assessment v.s year") + theme(legend.position = "none")



multiplot(pct_rate1,pct_assess1)
multiplot(pct_rate5,pct_assess5)
multiplot(pct_rate6,pct_assess6)
```
pct change of mill rate for each municipality
```{r}
# for each municipality
tax.list <- c("01","05","06")
for (i in 1:21){
  plot<-pct_final %>% filter(Municipalities == municipality.list[i]) %>% 
  filter(TaxClassCode %in% tax.list) %>% 
  ggplot(aes(x=Year, y=rate_pct, group=TaxClassCode, color=TaxClassCode)) +
    geom_line() + ggtitle(municipality.list[i])
  print(plot)
}
```


plot pct change of assessment
```{r}
# total trend of assessment 
for (i in 1:21){
  plot<-pct_final %>% filter(Municipalities == municipality.list[i]) %>% 
  filter(TaxClassCode %in% tax.list) %>% 
  ggplot(aes(x=Year, y=assessTotal_pct, group=TaxClassCode, color=TaxClassCode)) +
    geom_line() + ggtitle(municipality.list[i])
  print(plot)
}
```

plot pct change of tax(budget)
```{r, warning=F}
# total trend for budget 
for (i in 1:21){
  plot<-pct_final %>% filter(Municipalities == municipality.list[i]) %>% 
  filter(TaxClassCode %in% tax.list) %>% 
  ggplot(aes(x=Year, y=tax, group=TaxClassCode, color=TaxClassCode)) +
    geom_line() + ggtitle(municipality.list[i])
  print(plot)
}
```


```{r}
# plot rate, assessment, and budget for each municipality. 

for (i in 1:21){
  test1<-pct_final %>% filter(Municipalities == municipality.list[i]) %>% 
  filter(TaxClassCode %in% tax.list) %>% 
  ggplot(aes(x=Year, y=rate_pct, group=TaxClassCode, color=TaxClassCode)) +
   geom_line() 
  
  test2<-pct_final %>% filter(Municipalities == municipality.list[i]) %>% 
  filter(TaxClassCode %in% tax.list) %>% 
  ggplot(aes(x=Year, y=assessTotal_pct, group=TaxClassCode, color=TaxClassCode)) +
   geom_line() 

  test3<-pct_final %>% filter(Municipalities == municipality.list[i]) %>% 
  filter(TaxClassCode %in% tax.list) %>% 
  ggplot(aes(x=Year, y=tax)) +
   geom_line() + theme(legend.position = "none")
  
  multiplot(test1,test2,test3)
  
}
```

4. box plots of mill rates, grouped by region
```{r}
rate_boxes <- ggplot(dat_rate, aes(x=AddressAssessorMunicipalityDesc,y=rate,fill=TaxClassCode)) + geom_boxplot() + facet_wrap(~TaxClassCode) + theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "none")
rate_boxes 
```

5. Test correlations between past mill rates and assessed values and government budget.
```{r}
colnames(tax_modified) <- c("X","Municipalities","2016","2017","2018","2019")
head(tax_modified)
dat_tax_long <- gather(tax_modified, Year, TaxAmount, "2016":"2019", factor_key=TRUE)

#tax.all <- full_join(assessment_aggregate, tax_modified, by = 'Municipalities')

tax_modified1 <- gather(tax_modified, Year, tax, '2016':'2019', factor_key = TRUE)%>%
  rename(AddressAssessorMunicipalityDesc = Municipalities)

assessment_aggregate <- merge(assessment_aggregate, tax_modified1, by = c("AddressAssessorMunicipalityDesc","Year"))

correlation <- assessment_aggregate %>%
  group_by(AddressAssessorMunicipalityDesc,TaxClassCode)%>%
  summarise(cor(rate, tax))

correlation2 <- assessment_aggregate %>%
  group_by(AddressAssessorMunicipalityDesc,TaxClassCode)%>%
  summarise(cor(assessTotal, rate))



years <- c(2017, 2018, 2019)
city.cor <- data.frame(Municipality = municipality.list)
corr.list <- vector(length = 21)
corr.list
for(city in municipality.list){
  corr <- assessment_aggregate %>% filter(AddressAssessorMunicipalityDesc == city) %>% summarize(cor = cor(assessTotal, rate))
  #print(corr)
  corr.list <- cbind(corr.list, corr)
}
corr.list
city.cor <- cbind(city.cor,corr.list)
#city.cor
```

6. Compute autocorrelations of past mill rates to test the independence of mill rates. 
```{r}
# all white noise
for (i in 1:21) {
  print(municipality.list[i])
  dat_tmp <- dat_rate %>% filter(AddressAssessorMunicipalityDesc %in% municipality.list[i] & TaxClassCode %in% "1") %>% select(rate)
  if (municipality.list[i] != "Maple Ridge Rural") {
    as.ts(dat_tmp)
    acf(dat_tmp)
  }
}
for (i in 1:21) {
  print(municipality.list[i])
  dat_tmp <- dat_rate %>% filter(AddressAssessorMunicipalityDesc %in% municipality.list[i] & TaxClassCode %in% "5") %>% select(rate)
  if (municipality.list[i] != "Maple Ridge Rural" & municipality.list[i] != "White Rock" & municipality.list[i] != "Anmore" & municipality.list[i] != "Belcarra" & municipality.list[i] != "Lions Bay") {
    as.ts(dat_tmp)
    acf(dat_tmp)
  }
}
for (i in 1:21) {
  print(municipality.list[i])
  dat_tmp <- dat_rate %>% filter(AddressAssessorMunicipalityDesc %in% municipality.list[i] & TaxClassCode %in% "6") %>% select(rate)
  if (municipality.list[i] != "Maple Ridge Rural") {
    as.ts(dat_tmp)
    acf(dat_tmp)
  }
}
```

model fitting
(i) linear model
Not too much difference between linear 1 and linear 2 (with and without year).
This probably implies adding year doesn't make a difference.
```{r}
linear1<-lm(rate_pct~factor(Year)+factor(TaxClassCode)+factor(Municipalities)+assessTotal_pct+tax,data=pct_final)
summary(linear1)

linear2<-lm(rate_pct~factor(TaxClassCode)+factor(Municipalities)+assessTotal_pct+tax,data=pct_final)
summary(linear2)

# goodness of fit (all data)
library(broom)
linear1_fit<-augment(linear1)
sqrt(sum((linear1_fit$.resid)^2)/nrow(pct_final)) # 6.672786
linear2_fit<-augment(linear2)
sqrt(sum((linear2_fit$.resid)^2)/nrow(pct_final)) # 7.248359

```
linear 1: Residual standard error: 7.296 on 138 degrees of freedom
Multiple R-squared:  0.265,	Adjusted R-squared:  0.1265 
PMSE = 6.672786

linear 2: Residual standard error: 7.869 on 140 degrees of freedom
Multiple R-squared:  0.1327,	Adjusted R-squared:  -0.01593 
F-statistic: 0.8929 on 24 and 140 DF,  p-value: 0.6112
PMSE = 7.248359

we re-looked at the data and found percentage changes of tax in "Langley - City" and "Langley - Township" are too large (~400). We ignored the two municipalities and refit the linear model

```{r}
test<-pct_final %>% filter(Municipalities!="Langley - City") %>% 
  filter(Municipalities!="Langley - Township")
linear_test<-lm(rate_pct~factor(Year)+factor(TaxClassCode)+factor(Municipalities)+assessTotal_pct+tax,data=test)
summary(linear_test)

# goodness of fit
fit_linear_test<-augment(linear_test)
sqrt(sum((fit_linear_test$.resid)^2)/nrow(test)) # 6.767493

linear_test_2<-lm(rate_pct~factor(TaxClassCode)+factor(Municipalities)+assessTotal_pct+tax,data=test)
summary(linear_test_2)

# goodness of fit
fit_linear_test_2<-augment(linear_test_2)
sqrt(sum((fit_linear_test_2$.resid)^2)/nrow(test)) #  7.50047

```
After filtering Langely
with variable year:
Residual standard error: 7.429 on 122 degrees of freedom
Multiple R-squared:  0.2974,	Adjusted R-squared:  0.1592 
F-statistic: 2.152 on 24 and 122 DF,  p-value: 0.003567
PMSE: 6.767493

without variable year
Residual standard error: 8.167 on 124 degrees of freedom
Multiple R-squared:  0.137,	Adjusted R-squared:  -0.01609 
F-statistic: 0.8949 on 22 and 124 DF,  p-value: 0.6014
PMSE: 7.50047


```{r}
linear3<-lm(rate_pct~factor(Year)+factor(TaxClassCode)+factor(Municipalities),data=pct_final)
summary(linear3)
fit_linear3<-augment(linear3)
sqrt(sum((fit_linear3$.resid)^2)/nrow(test)) #  7.50047

```

Question: How to judge goodness of fit? Multiple R square? Adjusted R square? or mean prediction error?
**TODO: create training/test sets to test the prediction power!

(ii) Ridge, Lasso and elastic net.

Ridge Regression
reference: https://www.pluralsight.com/guides/linear-lasso-and-ridge-regression-with-r
```{r}
library(glmnet)
library(dummies)
dummy_year<-dummy(test$Year)
dummy_municipal<-dummy(test$Municipalities)
dummy_taxclass<-dummy(test$TaxClassCode)
# build x matrix
x<-cbind(dummy_year,dummy_municipal)
x<-cbind(x,dummy_taxclass)
x<-cbind(x,as.numeric(test$assessTotal_pct))
x<-cbind(x,as.numeric(test$tax))
y<-test$rate_pct
lambdas <- 10^seq(2, -3, by = -.1)
dim(x)
colnames(x)[26]<-paste("assessment")
colnames(x)[27]<-paste("tax")
colnames(x)

lambdas <- 10^seq(2, -3, by = -.1)
ridge_reg = glmnet(x, y, nlambda = 25, alpha = 0, family = 'gaussian', lambda = lambdas)
set.seed(450)
cv_ridge <- cv.glmnet(x, y, alpha = 0, lambda = lambdas, nfolds=10)
optimal_lambda <- cv_ridge$lambda.min
optimal_lambda
predictions_train <- predict(ridge_reg, s = optimal_lambda, newx = x)

# Compute R^2 from true and predicted values
eval_results <- function(true, predicted) {
  SSE <- sum((predicted - true)^2)
  SST <- sum((true - mean(true))^2)
  R_square <- 1 - SSE / SST
  RMSE = sqrt(SSE/nrow(predicted))
# Model performance metrics
data.frame(
  RMSE = RMSE,
  Rsquare = R_square
)
  
}

predictions_train <- predict(ridge_reg, s = optimal_lambda, newx = x)
eval_results(y, predictions_train)


```
RMSE=7.159649
Rsquare=0.2136659
Ridge regression doesn't seem to work well. 

Lasso 
```{r}
lambdas <- 10^seq(2, -3, by = -.1)

# Setting alpha = 1 implements lasso regression
set.seed(450)
lasso_reg <- cv.glmnet(x, y, alpha = 1, lambda = lambdas, standardize = TRUE, nfolds = 10)

# Best 
lambda_best <- lasso_reg$lambda.min;lambda_best

lasso_model <- glmnet(x, y, alpha = 1, lambda = lambda_best, standardize = TRUE)

predictions_train <- predict(lasso_model, s = lambda_best, newx = x)
eval_results(y, predictions_train)
```
RMSE = 7.221299, Rsquare=0.2000649

Elastic net: 
reference: https://daviddalpiaz.github.io/r4sl/elastic-net.html
```{r}
library(caret)
tibble::as_tibble(test)
cv_10 = trainControl(method = "cv", number = 10)
ridge = train(
  rate_pct ~ Year + Municipalities + TaxClassCode + assessTotal_pct + tax, data = test,
  method = "glmnet",
  trControl = cv_10
)
ridge
```
apha = 1 which implies lasso! refer to lasso.

Prediction power
train/test
```{r}
set.seed(450)
train_ind<-sample(165,120)
train1<-pct_final[train_ind,]
test1<-pct_final[-train_ind,]
```

linear model
```{r}
# full model with year
newx<-test1[,-c(5,6,7,8)]
y<-test1[,c(8)]
linear_1<-lm(rate_pct~factor(Year)+factor(TaxClassCode)+factor(Municipalities)+assessTotal_pct+tax,data=train1)
resid<-predict(linear_1,newdata = newx) - y
sqrt(sum(resid^2)/nrow(test1))
# pmse = 6.5688

# full model without year
linear_2<-lm(rate_pct~factor(TaxClassCode)+factor(Municipalities)+assessTotal_pct+tax,data=train1)
resid<-predict(linear_2,newdata = newx) - y
sqrt(sum(resid^2)/nrow(test1))
# 6.855429

# reduced variable
linear_3<-lm(rate_pct~factor(Year)+factor(TaxClassCode)+factor(Municipalities),data=train1)
resid<-predict(linear_3,newdata = newx) - y
sqrt(sum(resid^2)/nrow(test1))
# 6.570848
```
Lasso
```{r}
# create the whole matrix
dummy_year<-dummy(pct_final$Year)
dummy_municipal<-dummy(pct_final$Municipalities)
dummy_taxclass<-dummy(pct_final$TaxClassCode)
# build x matrix
x<-cbind(dummy_year,dummy_municipal)
x<-cbind(x,dummy_taxclass)
x<-cbind(x,as.numeric(pct_final$assessTotal_pct))
x<-cbind(x,as.numeric(pct_final$tax))
y<-as.matrix(pct_final$rate_pct)
dim(x) # 165  29
dim(y)
# creat x_train matrix and y_train
x_train<-x[train_ind,]
y_train<-y[train_ind,]
# create x_test matrix
x_test<-x[-train_ind,]
y_test<-y[-train_ind,]

lambdas <- 10^seq(2, -3, by = -.1)
# Setting alpha = 1 implements lasso regression
set.seed(450)
lasso_reg <- cv.glmnet(x_train, y_train, alpha = 1, lambda = lambdas, standardize = TRUE, nfolds = 10)

# Best 
lambda_best <- lasso_reg$lambda.min;lambda_best

lasso_model <- glmnet(x_train, y_train, alpha = 1, lambda = lambda_best, standardize = TRUE)

predictions_test <- predict(lasso_model, s = lambda_best, newx = x_test)
eval_results(y_test, predictions_test)
# 7.012128	
```

Ridge
```{r}
ridge_reg = glmnet(x_train, y_train, nlambda = 25, alpha = 0, family = 'gaussian', lambda = lambdas)
set.seed(450)
cv_ridge <- cv.glmnet(x_train, y_train, alpha = 0, lambda = lambdas, nfolds=10)
optimal_lambda <- cv_ridge$lambda.min
optimal_lambda
predictions_test <- predict(ridge_reg, s = optimal_lambda, newx = x_test)
eval_results(y_test, predictions_test)
# 6.885151	
```

