Municipalities <- aov(rate ~ factor(Municipality), data = assessment_aggregate)
#summary(Municipalities)
linear_full<-lm(rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount+tax,data=assessment_aggregate)
# summary(linear_full)
library(broom)
linear_full_fit<-augment(linear_full)
mse_full <- sqrt(sum((linear_full_fit$.resid)^2)/nrow(assessment_aggregate))
library(glmnet)
library(dummies)
dummy_year<-dummy(assessment_aggregate$Year)
dummy_municipal<-dummy(assessment_aggregate$Municipality)
dummy_taxclass<-dummy(assessment_aggregate$TaxClassCode)
# build x matrix
x<-cbind(dummy_municipal,dummy_year,dummy_taxclass,assessment_aggregate$assessTotal,assessment_aggregate$landTotal,assessment_aggregate$improvementTotal,assessment_aggregate$propertyCount,assessment_aggregate$tax)
y<-assessment_aggregate$rate
lambdas <- 10^seq(2, -3, by = -.1)
dim(x)
lambdas <- 10^seq(2, -3, by = -.1)
ridge_reg = glmnet(x, y, nlambda = 25, alpha = 0, family = 'gaussian', lambda = lambdas)
set.seed(450)
cv_ridge <- cv.glmnet(x, y, alpha = 0, lambda = lambdas, nfolds=10)
optimal_lambda <- cv_ridge$lambda.min
optimal_lambda
predictions_train <- predict(ridge_reg, s = optimal_lambda, newx = x)
# Compute R^2 from true and predicted values
eval_results <- function(true, predicted) {
SSE <- sum((predicted - true)^2)
SST <- sum((true - mean(true))^2)
R_square <- 1 - SSE / SST
MSPE = sqrt(SSE/nrow(predicted))
# Model performance metrics
data.frame(
MSPE = MSPE,
Rsquare = R_square
)
}
predictions_train <- predict(ridge_reg, s = optimal_lambda, newx = x)
ridge_mse <- eval_results(y, predictions_train)
# Setting alpha = 1 implements lasso regression
set.seed(450)
lasso_reg <- cv.glmnet(x, y, alpha = 1, lambda = lambdas, standardize = TRUE, nfolds = 10)
# Best
lambda_best <- lasso_reg$lambda.min;lambda_best
lasso_model <- glmnet(x, y, alpha = 1, lambda = lambda_best, standardize = TRUE)
predictions_train <- predict(lasso_model, s = lambda_best, newx = x)
lasso_mse <- eval_results(y, predictions_train)
lasso_reg <- cv.glmnet(x, y, alpha = 1, lambda = lambdas, standardize = TRUE, nfolds = 10)
# Best
lambda_best <- lasso_reg$lambda.min;lambda_best
# Best
lambda_best <- lasso_reg$lambda.min;lambda_best
# Setting alpha = 1 implements lasso regression
set.seed(450)
lasso_reg <- cv.glmnet(x, y, alpha = 1, lambda = lambdas, standardize = TRUE, nfolds = 10)
# Best
lambda_best <- lasso_reg$lambda.min;#lambda_best
lasso_model <- glmnet(x, y, alpha = 1, lambda = lambda_best, standardize = TRUE)
predictions_train <- predict(lasso_model, s = lambda_best, newx = x)
lasso_mse <- eval_results(y, predictions_train)
library(caret)
tibble::as_tibble(assessment_aggregate)
cv_10 = trainControl(method = "cv", number = 10)
elastic_net = train(
rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount, data = assessment_aggregate,
method = "glmnet",
trControl = cv_10
)
tibble::as_tibble(assessment_aggregate)
tibble::assessment_aggregate <- as_tibble(assessment_aggregate)
library(caret)
assessment_aggregate <- tibble::as_tibble(assessment_aggregate)
cv_10 = trainControl(method = "cv", number = 10)
elastic_net = train(
rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount, data = assessment_aggregate,
method = "glmnet",
trControl = cv_10
)
library(caret)
assessment_aggregate <- tibble::as_tibble(assessment_aggregate)
cv_10 = trainControl(method = "cv", number = 10)
elastic_net = train(
rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount, data = assessment_aggregate,
method = "glmnet",
trControl = cv_10
)
library(caret)
assessment_aggregate <- tibble::as_tibble(assessment_aggregate)
cv_10 = trainControl(method = "cv", number = 10)
elastic_net = train(
rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount, data = assessment_aggregate,
method = "glmnet",
trControl = cv_10
)
library(caret)
#assessment_aggregate <- tibble::as_tibble(assessment_aggregate)
cv_10 = trainControl(method = "cv", number = 10)
elastic_net = train(
rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount, data = assessment_aggregate,
method = "glmnet",
trControl = cv_10
)
library(caret)
tibble::as_tibble(assessment_aggregate)
cv_10 = trainControl(method = "cv", number = 10)
elastic_net = train(
rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount, data = assessment_aggregate,
method = "glmnet",
trControl = cv_10
)
set.seed(450)
train_ind<-sample(218,218-50)
train<-assessment_aggregate[train_ind,]
test<-assessment_aggregate[-train_ind,]
# Full linear model
newx<-test[,-c(8,9)]
y<-test[,c(8)]
linear_1<-lm(rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount+tax,data=train)
resid<-predict(linear_1,newdata = newx) - y
full_mspe <- sqrt(sum(resid^2)/nrow(test))
# Reduced model
linear_2<-lm(rate~factor(Year)+factor(TaxClassCode)+factor(Municipality)+assessTotal+landTotal,data=train)
resid<-predict(linear_2,newdata = newx) - y
reduced_mspe <- sqrt(sum(resid^2)/nrow(test))
# Lasso
# create the whole matrix
y<-as.matrix(assessment_aggregate$rate)
dim(x) # 165  29
dim(y)
# creat x_train matrix and y_train
x_train<-x[train_ind,]
y_train<-y[train_ind,]
# create x_test matrix
x_test<-x[-train_ind,]
y_test<-y[-train_ind,]
# Setting alpha = 1 implements lasso regression
set.seed(450)
lasso_reg <- cv.glmnet(x_train, y_train, alpha = 1, lambda = lambdas, standardize = TRUE, nfolds = 10)
# Best
lambda_best <- lasso_reg$lambda.min;lambda_best
lasso_model <- glmnet(x_train, y_train, alpha = 1, lambda = lambda_best, standardize = TRUE)
predictions_test <- predict(lasso_model, s = lambda_best, newx = x_test)
lasso_mspe <- eval_results(y_test, predictions_test)
# Ridge
ridge_reg = glmnet(x_train, y_train, nlambda = 25, alpha = 0, family = 'gaussian', lambda = lambdas)
set.seed(450)
cv_ridge <- cv.glmnet(x_train, y_train, alpha = 0, lambda = lambdas, nfolds=10)
optimal_lambda <- cv_ridge$lambda.min
optimal_lambda
predictions_test <- predict(ridge_reg, s = optimal_lambda, newx = x_test)
ridge_mspe <- eval_results(y_test, predictions_test)
# Elastic Net
tibble::as_tibble(assessment_aggregate[train_ind,])
cv_10 = trainControl(method = "cv", number = 10)
elastic_net = train(
rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount+tax,
data = assessment_aggregate[train_ind,],
method = "glmnet",
trControl = cv_10
)
elastic_reg = glmnet(x_train, y_train, nlambda = 25, alpha = 1, family = 'gaussian', lambda =  0.06549203)
predictions_test <- predict(elastic_reg, newx = x_test)
elastic_net_mspe <- eval_results(y_test, predictions_test)
library(glmnet)
library(dummies)
dummy_year<-dummy(assessment_aggregate$Year)
dummy_municipal<-dummy(assessment_aggregate$Municipality)
dummy_taxclass<-dummy(assessment_aggregate$TaxClassCode)
# build x matrix
x<-cbind(dummy_municipal,dummy_year,dummy_taxclass,assessment_aggregate$assessTotal,assessment_aggregate$landTotal,assessment_aggregate$improvementTotal,assessment_aggregate$propertyCount,assessment_aggregate$tax)
y<-assessment_aggregate$rate
lambdas <- 10^seq(2, -3, by = -.1)
#dim(x)
lambdas <- 10^seq(2, -3, by = -.1)
ridge_reg = glmnet(x, y, nlambda = 25, alpha = 0, family = 'gaussian', lambda = lambdas)
set.seed(450)
cv_ridge <- cv.glmnet(x, y, alpha = 0, lambda = lambdas, nfolds=10)
optimal_lambda <- cv_ridge$lambda.min
#optimal_lambda
predictions_train <- predict(ridge_reg, s = optimal_lambda, newx = x)
# Compute R^2 from true and predicted values
eval_results <- function(true, predicted) {
SSE <- sum((predicted - true)^2)
SST <- sum((true - mean(true))^2)
R_square <- 1 - SSE / SST
MSPE = sqrt(SSE/nrow(predicted))
# Model performance metrics
data.frame(
MSPE = MSPE,
Rsquare = R_square
)
}
predictions_train <- predict(ridge_reg, s = optimal_lambda, newx = x)
ridge_mse <- eval_results(y, predictions_train)
# Setting alpha = 1 implements lasso regression
set.seed(450)
lasso_reg <- cv.glmnet(x, y, alpha = 1, lambda = lambdas, standardize = TRUE, nfolds = 10)
# Best
lambda_best <- lasso_reg$lambda.min;#lambda_best
lasso_model <- glmnet(x, y, alpha = 1, lambda = lambda_best, standardize = TRUE)
predictions_train <- predict(lasso_model, s = lambda_best, newx = x)
lasso_mse <- eval_results(y, predictions_train)
library(caret)
#tibble::as_tibble(assessment_aggregate)
cv_10 = trainControl(method = "cv", number = 10)
elastic_net = train(
rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount, data = assessment_aggregate,
method = "glmnet",
trControl = cv_10
)
set.seed(450)
train_ind<-sample(218,218-50)
train<-assessment_aggregate[train_ind,]
test<-assessment_aggregate[-train_ind,]
# Full linear model
newx<-test[,-c(8,9)]
y<-test[,c(8)]
linear_1<-lm(rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount+tax,data=train)
resid<-predict(linear_1,newdata = newx) - y
full_mspe <- sqrt(sum(resid^2)/nrow(test))
# Reduced model
linear_2<-lm(rate~factor(Year)+factor(TaxClassCode)+factor(Municipality)+assessTotal+landTotal,data=train)
resid<-predict(linear_2,newdata = newx) - y
reduced_mspe <- sqrt(sum(resid^2)/nrow(test))
# Lasso
# create the whole matrix
y<-as.matrix(assessment_aggregate$rate)
dim(x) # 165  29
dim(y)
# creat x_train matrix and y_train
x_train<-x[train_ind,]
y_train<-y[train_ind,]
# create x_test matrix
x_test<-x[-train_ind,]
y_test<-y[-train_ind,]
# Setting alpha = 1 implements lasso regression
set.seed(450)
lasso_reg <- cv.glmnet(x_train, y_train, alpha = 1, lambda = lambdas, standardize = TRUE, nfolds = 10)
# Best
lambda_best <- lasso_reg$lambda.min;lambda_best
lasso_model <- glmnet(x_train, y_train, alpha = 1, lambda = lambda_best, standardize = TRUE)
predictions_test <- predict(lasso_model, s = lambda_best, newx = x_test)
lasso_mspe <- eval_results(y_test, predictions_test)
# Ridge
ridge_reg = glmnet(x_train, y_train, nlambda = 25, alpha = 0, family = 'gaussian', lambda = lambdas)
set.seed(450)
cv_ridge <- cv.glmnet(x_train, y_train, alpha = 0, lambda = lambdas, nfolds=10)
optimal_lambda <- cv_ridge$lambda.min
optimal_lambda
predictions_test <- predict(ridge_reg, s = optimal_lambda, newx = x_test)
ridge_mspe <- eval_results(y_test, predictions_test)
# Elastic Net
tibble::as_tibble(assessment_aggregate[train_ind,])
cv_10 = trainControl(method = "cv", number = 10)
elastic_net = train(
rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount+tax,
data = assessment_aggregate[train_ind,],
method = "glmnet",
trControl = cv_10
)
elastic_reg = glmnet(x_train, y_train, nlambda = 25, alpha = 1, family = 'gaussian', lambda =  0.06549203)
predictions_test <- predict(elastic_reg, newx = x_test)
elastic_net_mspe <- eval_results(y_test, predictions_test)
#optimal_lambda
predictions_test <- predict(ridge_reg, s = optimal_lambda, newx = x_test)
#optimal_lambda
predictions_test <- predict(ridge_reg, s = optimal_lambda, newx = x_test)
ridge_mspe <- eval_results(y_test, predictions_test)
# Elastic Net
tibble::as_tibble(assessment_aggregate[train_ind,])
set.seed(450)
train_ind<-sample(218,218-50)
train<-assessment_aggregate[train_ind,]
test<-assessment_aggregate[-train_ind,]
# Full linear model
newx<-test[,-c(8,9)]
y<-test[,c(8)]
linear_1<-lm(rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount+tax,data=train)
resid<-predict(linear_1,newdata = newx) - y
full_mspe <- sqrt(sum(resid^2)/nrow(test))
# Reduced model
linear_2<-lm(rate~factor(Year)+factor(TaxClassCode)+factor(Municipality)+assessTotal+landTotal,data=train)
resid<-predict(linear_2,newdata = newx) - y
reduced_mspe <- sqrt(sum(resid^2)/nrow(test))
# Lasso
# create the whole matrix
y<-as.matrix(assessment_aggregate$rate)
#dim(x) # 165  29
#dim(y)
# creat x_train matrix and y_train
x_train<-x[train_ind,]
y_train<-y[train_ind,]
# create x_test matrix
x_test<-x[-train_ind,]
y_test<-y[-train_ind,]
# Setting alpha = 1 implements lasso regression
set.seed(450)
lasso_reg <- cv.glmnet(x_train, y_train, alpha = 1, lambda = lambdas, standardize = TRUE, nfolds = 10)
# Best
lambda_best <- lasso_reg$lambda.min;lambda_best
lasso_model <- glmnet(x_train, y_train, alpha = 1, lambda = lambda_best, standardize = TRUE)
predictions_test <- predict(lasso_model, s = lambda_best, newx = x_test)
lasso_mspe <- eval_results(y_test, predictions_test)
# Ridge
ridge_reg = glmnet(x_train, y_train, nlambda = 25, alpha = 0, family = 'gaussian', lambda = lambdas)
set.seed(450)
cv_ridge <- cv.glmnet(x_train, y_train, alpha = 0, lambda = lambdas, nfolds=10)
optimal_lambda <- cv_ridge$lambda.min
#optimal_lambda
predictions_test <- predict(ridge_reg, s = optimal_lambda, newx = x_test)
ridge_mspe <- eval_results(y_test, predictions_test)
# Elastic Net
#tibble::as_tibble(assessment_aggregate[train_ind,])
cv_10 = trainControl(method = "cv", number = 10)
elastic_net = train(
rate~factor(Municipality)+factor(Year)+factor(TaxClassCode)+assessTotal+landTotal+improvementTotal+propertyCount+tax,
data = assessment_aggregate[train_ind,],
method = "glmnet",
trControl = cv_10
)
elastic_reg = glmnet(x_train, y_train, nlambda = 25, alpha = 1, family = 'gaussian', lambda =  0.06549203)
predictions_test <- predict(elastic_reg, newx = x_test)
elastic_net_mspe <- eval_results(y_test, predictions_test)
# create x_test matrix
x_test<-x[-train_ind,]
y_test<-y[-train_ind,]
# Setting alpha = 1 implements lasso regression
set.seed(450)
lasso_reg <- cv.glmnet(x_train, y_train, alpha = 1, lambda = lambdas, standardize = TRUE, nfolds = 10)
# Best
lambda_best <- lasso_reg$lambda.min;lambda_best
knitr::opts_chunk$set(echo = TRUE)
# install.packages(c("dplyr","here","readxl"))
library(dplyr)
library(here)
library(readxl)
library(here)
assessment.1620 <- read.csv(here("data/Assessment", "2016 - 2020 Raw.csv"),header = F)
col.name <- read_excel(here("data/Assessment", "2020 Only.xlsx"))
colnames(assessment.1620) <- colnames(col.name)
municipality.list = c(
"Burnaby",
"Coquitlam",
"Delta",
"Langley - City",
"Langley - Township",
"Maple Ridge",
"Maple Ridge Rural",
"North Vancouver - City",
"North Vancouver - Dist",
"Pitt Meadows",
"Port Coquitlam",
"Port Moody",
"Richmond",
"Surrey",
"Vancouver",
"White Rock",
"West Vancouver",
"Bowen Island",
"Anmore",
"Belcarra",
"Lions Bay"，
municipality.list = c(
"Burnaby",
"Coquitlam",
"Delta",
"Langley - City",
"Langley - Township",
"Maple Ridge",
"Maple Ridge Rural",
"North Vancouver - City",
"North Vancouver - Dist",
"Pitt Meadows",
"Port Coquitlam",
"Port Moody",
"Richmond",
"Surrey",
"Vancouver",
"White Rock",
"West Vancouver",
"Bowen Island",
"Anmore",
"Belcarra",
"Lions Bay",
"New Westminster")
# Select only relevent features
assessment.thin <- distinct(assessment.1620) %>%
select(PIC,Year,AssessorAreaCode:AddressAssessorMunicipalityDesc, TaxClassCode:TaxClassTaxRate)%>%
filter(TaxClassCode %in% c("01","05","06"),
AddressAssessorMunicipalityDesc %in% municipality.list,
Year %in% c(2016,2017,2018,2019))
# Overview
head(assessment.thin)
dim(assessment.thin)
str(assessment.thin)
assessment.thin[assessment.thin == "NULL"] <- NA
assessment.thin$TaxClassTaxRate <- as.numeric(as.character(assessment.thin$TaxClassTaxRate))
# Check Missing Value
for (feature in colnames(assessment.thin)){
variable = eval(parse(text = paste0("assessment.thin$",feature)))
null.count = sum(is.na(variable))
print(paste(feature,null.count, sep = ":"))
}
(TaxClassTaxRate.text <- assessment.thin%>%
group_by(Year, AddressAssessorMunicipalityDesc,TaxClassCode)%>%
filter(!is.na(TaxClassTaxRate))%>%
summarise(test = var(as.numeric(as.character(TaxClassTaxRate))))%>%
filter(test !=0))
Langley <- assessment.thin%>%
filter(Year == 2019,
AddressAssessorMunicipalityDesc == "Langley - City",
TaxClassCode == "06")
cat("Langley:")
table(Langley$TaxClassTaxRate)
Burnaby <- assessment.thin%>%
filter(Year == 2019,
AddressAssessorMunicipalityDesc == "Burnaby",
TaxClassCode == "06")
cat("Burnaby:")
table(Burnaby$TaxClassTaxRate)
Vancouver <- assessment.thin%>%
filter(Year == 2019,
AddressAssessorMunicipalityDesc == "Vancouver",
TaxClassCode == "01")
cat("Vancouver:")
table(Vancouver$TaxClassTaxRate)
TaxClassTaxRate.text
Langley <- assessment.thin%>%
filter(Year == 2019,
AddressAssessorMunicipalityDesc == "New Westminster",
TaxClassCode == "06")
NewWest <- assessment.thin%>%
filter(Year == 2019,
AddressAssessorMunicipalityDesc == "New Westminster",
TaxClassCode == "06")
NewWest
NewWest
View(NewWest)
assessment.rate <- assessment.thin%>%
mutate(TaxClassTaxRate = case_when(Year == 2019 &
AddressAssessorMunicipalityDesc == "Langley - City" &
TaxClassCode == "06" ~ 11.8916,
Year == 2019 &
AddressAssessorMunicipalityDesc == "Burnaby" &
TaxClassCode == "06" ~ 10.0987,
Year == 2019 &
AddressAssessorMunicipalityDesc == "Vancouver" &
TaxClassCode == "01" ~ 2.56116,
Year == 2019 &
AddressAssessorMunicipalityDesc == "New Westminster" &
TaxClassCode == "06" ~ 14.2158,
TRUE ~ TaxClassTaxRate))
Delta <- assessment.rate%>%
filter(!is.na(TaxClassTaxRate),
Year %in% c(2017,2018,2019),
AddressAssessorMunicipalityDesc == "Delta")%>%
group_by(AddressAssessorMunicipalityDesc, Year, TaxClassCode)%>%
summarise(rate = mean(TaxClassTaxRate))
assessment.rate <- merge(assessment.rate, Delta,
by = c("AddressAssessorMunicipalityDesc", "Year", "TaxClassCode"), all = TRUE)%>%
mutate(TaxClassTaxRate = case_when(Year %in% c(2017,2018,2019) &
AddressAssessorMunicipalityDesc == "Delta" ~ rate,
TRUE ~ TaxClassTaxRate))%>%
select(-rate)
## Check if there is still inconsistancy
(TaxClassTaxRate.text2 <- assessment.rate%>%
group_by(Year, AddressAssessorMunicipalityDesc,TaxClassCode)%>%
filter(!is.na(TaxClassTaxRate))%>%
summarise(test = var(TaxClassTaxRate))%>%
filter(test !=0))
TaxClassTaxRate.text2
assessment.agg <- assessment.rate%>%
group_by(Year, AddressAssessorMunicipalityDesc,TaxClassCode)%>%
filter(!is.na(TaxClassTaxRate))%>%
summarise(rate = unique(TaxClassTaxRate))
assessment.impute <- merge(assessment.rate, assessment.agg,
by = c("AddressAssessorMunicipalityDesc", "Year", "TaxClassCode"), all = TRUE)%>%
mutate(TaxClassTaxRate = rate)%>%
select(-rate)
(TaxClassTaxRate.text3 <- assessment.impute%>%
group_by(Year, AddressAssessorMunicipalityDesc,TaxClassCode)%>%
summarise(test = var(TaxClassTaxRate))%>%
filter(test !=0))
# List of region that don't have TaxRate
(assessment.miss <- assessment.impute%>%
filter(is.na(TaxClassTaxRate))%>%
group_by(Year, AddressAssessorMunicipalityDesc,TaxClassCode)%>%
summarise(propertyCount = length(unique(PIC))))
# Cleaned data table
assessment.final <- assessment.impute%>%
filter(!is.na(TaxClassTaxRate))
## Aggrehate by Year, AddressAssessorMunicipalityDesc,TaxClassCode
assessment.aggregate <- assessment.final%>%
group_by(Year, AddressAssessorMunicipalityDesc,TaxClassCode)%>%
summarise(assessTotal = sum(AssessedValueAmt),
landTotal = sum(AssessedValueAmt[AssetTypeDesc=="Land"]),
improvementTotal = sum(AssessedValueAmt[AssetTypeDesc=="Improvement"]),
propertyCount = length(unique(PIC)),
rate = unique(TaxClassTaxRate))
## Transform into percentage change
assessment.pct <- assessment.aggregate%>%
group_by(AddressAssessorMunicipalityDesc, TaxClassCode)%>%
arrange(Year, .by_group = TRUE) %>%
mutate(assessTotal_pct = (assessTotal/lag(assessTotal) - 1) * 100,
landTotal_pct = (landTotal/lag(landTotal) - 1) * 100,
improvementTotal_pct = (improvementTotal/lag(improvementTotal) - 1) * 100,
propertyCount_pct = (propertyCount/lag(propertyCount) - 1) * 100,
rate_pct = (rate/lag(rate) - 1) * 100)%>%
select(-c(assessTotal,landTotal, improvementTotal, propertyCount, rate))
View(assessment.final)
View(assessment.agg)
View(assessment.agg)
save.image("~/Documents/GitHub/RealEstate/src/Untitled.RData")
